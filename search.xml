<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql快照读</title>
      <link href="/2022/05/05/mysql%E5%BF%AB%E7%85%A7%E8%AF%BB/"/>
      <url>/2022/05/05/mysql%E5%BF%AB%E7%85%A7%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>mysql 当前读与快照读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">快照读就是普通查询</span><br><span class="line">select * from xx；</span><br><span class="line"></span><br><span class="line">当前读 就是想要最新的数据，类似</span><br><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br><span class="line">update ...</span><br><span class="line">delete ...</span><br><span class="line">insert ...</span><br></pre></td></tr></table></figure><p>快照读就是，开启了事务，做了某些操作<br>而其他人只能读到开启事务前的数据</p><hr><p>需要了解的前置知识<br>InnoDB 跟 MyISAM 区别<br>主要是 InnoDB 支持事务，MyISAM 不支持<br>其他先不管了</p><p>参考链接:<br><a href="https://www.zhihu.com/question/20596402">https://www.zhihu.com/question/20596402</a></p><p>什么是事务？<br>我们知道事务具有ACID四个特性。也即：原子性，一致性，隔离性，持久性<br>简单来说就是<br>提交数据，连续保存 3 条数据<br>要么都成功保存<br>要么都失败，一条也不保存</p><p>如何使用事务？<br>在mysql命令框里输入<br>BEGIN 开始一个事务<br>inset xxx 插入东西<br>ROLLBACK 事务回滚<br>COMMIT 事务确认(提交)</p><p>参考连接:<br><a href="https://www.runoob.com/mysql/mysql-transaction.html">https://www.runoob.com/mysql/mysql-transaction.html</a></p><p>需要注意，MySQL 默认是会有自动提交的<br>SET AUTOCOMMIT=0 禁止自动提交<br>（只对当前页有效）</p><p>那么跟 自动提交 有啥关系呢？<br>自动提交就是 auto commit<br>比如你开了一个事务<br>begin<br>然后做了操作<br>然后又begin<br>mysql就帮你提交第二个begin之前的操作了</p><p>参考链接：<br><a href="https://blog.csdn.net/u014163312/article/details/120990961">https://blog.csdn.net/u014163312/article/details/120990961</a></p><p>事务隔离级别又有啥不同？<br>脏读<br>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，<br>也就是可能最终不会存到数据库中，也就是不存在的数据。<br>读到了并一定最终存在的数据，这就是脏读。</p><p>可重复读<br>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻<br>读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作</p><p>不可重复读<br>对比可重复读，不可重复读指的是在同一事务内，<br>不同的时刻读到的同一批数据可能是不一样的，<br>可能会受到其他事务的影响，比如其他事务改了这批数据并提交了</p><p>幻读<br>幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，<br>此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，<br>而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务  刚插入进来的，<br>让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读</p><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/117476959">https://zhuanlan.zhihu.com/p/117476959</a>  </p><hr><p>总结一下，快照读就是<br>在 mysql 的 InnoDB 存储引擎下<br>事务隔离级别为 可重复读<br>连接数据库的 A 通过开启事务，插入了一些数据，但是没有提交<br>连接数据库的 B 查询数据，比如：<br>select * from t;<br>是查询不到 A 插入的数据的，此时为快照读<br>如果使用<br>select * from t for update;<br>这种查询语句是叫 当前读<br>就会一直等待 A 更新数据，直到超时中断查询  </p><p>其他没了，就是这么简单</p><p>这里有一个坑是，一定要使用两个终端去连接数据库，作为不同的数据库连接<br>才能验证快照读，而使用一个软件，一个终端，<br>或者在同一个软件里，会使用同一个连接去查询数据库，导致无法复现快照读<br>（坑的我有点怀疑为什么无法复现）</p><p>备注：一些操作<br>看看当前mysql的事务隔离级别<br>select @@tx_isolation;<br>执行结果<br>REPEATABLE-READ</p><p>InnoDB 存储引擎的事务隔离级别默认为：可重复读<br>查看自动提交状态<br>select @@autocommit;<br>执行结果<br>1</p><p>关闭自动提交<br>set autocommit=0;</p><p>参考链接:<br><a href="https://www.cloudcoders.cn/2021/09/16/082/">https://www.cloudcoders.cn/2021/09/16/082/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux mac 安全删除文件</title>
      <link href="/2021/12/22/linux-mac-%E5%AE%89%E5%85%A8%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"/>
      <url>/2021/12/22/linux-mac-%E5%AE%89%E5%85%A8%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>为什么需要安全删除呢, 因为删除不能后悔, 那有可能删错文件<br>那就太惨了<br>mac 我尝试了  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install safe-rm</span><br></pre></td></tr></table></figure><p>安装成功了, 但是删除的文件不知道到哪里去了…<br>我搜了全局, 没怎么搜到, 算了, 从 git 拉取吧  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mac</span><br><span class="line"></span><br><span class="line">git clone https://github.com/kaelzhang/shell-safe-rm ~/Downloads/shell-safe-rm</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line">alias rm=&#x27;~/Downloads/shell-safe-rm/bin/rm.sh&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mac 删除的文件在 ~/.Trash<br>linux 删除的文件在 $HOME/.local/share/Trash/files (还没检验)  </p><p>参考资料  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/f65a75aab6ac/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习 redis 作为消息队列</title>
      <link href="/2021/12/21/%E5%AD%A6%E4%B9%A0-redis-%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/12/21/%E5%AD%A6%E4%B9%A0-redis-%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>pub/sub<br>优势:</p><ol><li>支持发布订阅, 阻塞接受消息, 避免 CPU 空转  </li><li>支持多组生产者, 消费者处理消息, 可以制定规则获取  </li></ol><p>缺点:</p><ol><li>丢数据<ol><li>消费者下线</li><li>redis 宕机</li><li>消息堆积</li></ol></li></ol><p>1, 消费者下线为啥会丢消息?<br>因为 redis 实时转发, 没有数据存储<br>如果所有消费者下线, 那么所有消息都会丢失<br>消费者上线后, 只能接受新的消息  </p><p>2, 消息堆积为啥会丢消息?<br>因为 redis pub/sub 模式中间是有一个缓冲区的, 配置为  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure><p>它的参数含义如下：<br>32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线<br>8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线  </p><p>redis Stream<br>优势:<br>1, 支持阻塞式获取消息<br>2, 支持发布/订阅<br>3, 支持设置消息处理完成, 不然会一直在队列中, 可以重复消费<br>4, 可以持久化, 支持 RDB 与 AOF<br>5, 消息堆积时, 可以限流生产者, 或者丢弃旧消息  </p><p>如何丢弃旧消息?<br>丢弃旧消息的意思是, 保持固定长度的消息, 滚动删除最早的消息<br>XADD queue MAXLEN 10000 * name zhangsan  </p><p>RDB 与 AOF 是什么?<br>RDB 是 redis database, 指的是将数据以快照形式写入磁盘中<br>AOF append only file 指的是执行过的写指令以日志的记录下来, 然后用来恢复  </p><p>redis 与专业的消息队列差在哪里 (比如RabbitMQ, Kafka)?  </p><ol><li>redis 作为中间件有可能会丢数据  <ol><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的, Redis 宕机时会存在数据丢失的可能  </li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能<br> （从库还未同步完成主库发来的数据，就被提成主库）  </li></ol></li></ol><p>RabbitMQ 或 Kafka 这类专业的队列中间件, 写入数据是向多个节点写入所以一个节点坏了也没啥关系  </p><p>2, 消息堆积<br>    redis 本身是存在内存当中, 消息积压时候, 就会 out of memory (oom), 内存不够用<br>    所以, redis 用固定长度来解决这个问题, 但是会丢掉旧的数据<br>    RabbitMQ 或 Kafka 存在磁盘, 比内存便宜很多很多, 所以不怕积压消息  </p><p>比专业的消息队列好在哪里?<br>redis 比 RabbitMQ 或 Kafka 更加轻量, 不在意数据积压之后会丢失<br>以及写入量小, 可以用 redis  </p><p>根据一下链接学习:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 怎么做消息队列？ - Kaito的回答 - 知乎</span><br><span class="line">https://www.zhihu.com/question/20795043/answer/1931265868</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅使用 tmux</title>
      <link href="/2021/12/20/tmux-%E5%8E%86%E5%8F%B2%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/12/20/tmux-%E5%8E%86%E5%8F%B2%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>tmux 的使用<br>为啥要用 tmux 最大的好处是可以看会话中的历史输出<br>以及关闭窗口会, 程序会继续执行  </p><p>所有窗口<br>tmux ls</p><p>新建一个会话<br>tmux new -s bb</p><p>进入会话<br>tmux a -t 编号或名字<br>(a的意思是 attach)</p><p>离开当前会话<br>Ctrl+b d</p><p>关闭当前会话<br>exit</p><p>在会话里面列出所有会话<br>Ctrl+b s</p><p>重命名会话<br>tmux rename-session -t 0 <new-name></p><p>当前会话右边加一个窗格<br>ctrl+b %</p><p>划分上下两个窗格<br>Ctrl+b “</p><p>光标切换到不同窗格<br>trl+b 方向键上下左右  </p><p>关闭当前窗格<br>Ctrl+b x</p><p>调整窗格大小 (mac 按键冲突了)<br>Ctrl+b Ctrl+方向键</p><p>最大化独立窗口, 再使用一次会变回原来大小<br>Ctrl+b z</p><p>当前窗格与上下一个窗格交换位置<br>Ctrl+b {<br>Ctrl+b }</p><p>创建一个新窗口，状态栏会显示多个窗口的信息<br>Ctrl+b c</p><p>从列表中选择窗口<br>Ctrl+b w</p><p>tmux 查看历史输出<br>在会话中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+b [</span><br></pre></td></tr></table></figure><p>即进入历史输出信息查看模式<br>可通过键盘上的上下左右键来滚动历史输出信息。<br>如果要退出查看模式，按下 q 即可  </p><p>重开机自动恢复tmux<br>装插件 tmux-continuum  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">某个位置创建文件夹存放以下插件</span><br><span class="line">git clone https://github.com/tmux-plugins/tmux-resurrect.git</span><br><span class="line">git clone https://github.com/tmux-plugins/tmux-continuum.git</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置 tmux  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.tmux.conf</span><br><span class="line"># 但是似乎没效果</span><br><span class="line">set -g default-terminal &quot;screen-256color&quot;</span><br><span class="line"># 历史输出可以看 1 万行</span><br><span class="line">set -g history-limit 10000</span><br><span class="line"></span><br><span class="line"># 鼠标可以滚动命令行, 以及调窗口大小, 点击换窗格</span><br><span class="line">set-option -g mouse on</span><br><span class="line"></span><br><span class="line"># 自动保存 1 分钟保存一次 它会保存到 ~/.tmux/resurrect </span><br><span class="line">run-shell ~/Downloads/tmux/tmux-continuum/continuum.tmux</span><br><span class="line">set -g @continuum-save-interval &#x27;1&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更新配置</span><br><span class="line">tmux source-file &lt;path&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line">#  打开命令行直接进入 tmux</span><br><span class="line"># 一样可以实现自动连接已存在的会话,否则会新开一个</span><br><span class="line">if [[ -z &quot;$TMUX&quot; ]] ;then</span><br><span class="line">    ID=&quot;`tmux ls | grep -vm1 attached | cut -d: -f1`&quot; # get the id of a deattached session</span><br><span class="line">    if [[ -z &quot;$ID&quot; ]] ;then # if not available create a new one</span><br><span class="line">        tmux new-session</span><br><span class="line">    else</span><br><span class="line">        tmux attach-session -t &quot;$ID&quot; # if available attach to it</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>复制粘贴<br>mac<br>从一开始按住 fn<br>然后 command c v 复制粘贴  </p><p>linux (还没确认)<br>从一开始按住 shift<br>然后 ctrl c v 复制粘贴  </p><p>写的好的链接  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/zuoruining/p/11074367.html</span><br><span class="line">阮一峰</span><br><span class="line">http://www.ruanyifeng.com/blog/2019/10/tmux.html</span><br><span class="line">tmux 官网</span><br><span class="line">https://github.com/tmux/tmux/wiki</span><br><span class="line">tmux 中文官网</span><br><span class="line">https://wiki.archlinux.org/title/Tmux_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在 github pages 搭建一个 hexo 博客</title>
      <link href="/2021/12/17/%E5%A6%82%E4%BD%95%E5%9C%A8-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA-hexo-%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/12/17/%E5%A6%82%E4%BD%95%E5%9C%A8-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA-hexo-%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1, 安装 node</p><p>2, npm install -g hexo-cli</p><p>3, 建立一个文件夹, 输入 hexo init blog</p><p>4, hexo g 生成静态页面</p><p>5, hexo s 建立服务器</p><p>6, 登陆 localhost:4000 查看</p><p>7, 在 github 建立一个项目, 项目名字是 x.github.io, x 是你的名字</p><p>8, 编辑文件夹中的 _config.yml 配置文件, 在最后填上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git 路径</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>8, 安装 hexo git 插件 npm install hexo-deployer-git –save</p><p>9, 配置 ssh 秘钥去连接 github</p><p>10, 部署命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>11, 登陆 x.github.io 就可以看到效果了</p><p>12, 安装管理后台 npm install hexo-admin –save</p><p>13, 在本地 hexo s 之后, 可以 localhost:4000/admin/ 查看</p><p>14, 绑定域名, 打开阿里云, 点击绑定域名, 选择 CNAME 记录, 然后添加 x.github.io</p><p>15, 登陆 github 选择 x.github.io 项目, 然后点击 github pages</p><p>16, 然后在 custom domain 添加域名</p><p>17, 本地 blog/source 新建一个文件, 写入域名, 保存名字为 CNAME</p><p>参考链接</p><p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><p>hexo 官网</p><p><a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
